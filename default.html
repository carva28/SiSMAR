<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin="" />

    <script src="js/jquery.js">
    </script>
    <script lang="javascript" src="js/xlsx.full.min.js"></script>


    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js" integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg==" crossorigin=""></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.4.0/gpx.min.js"></script>
    <style>
        h2 {
            text-align: center;
        }
        
        #issMap {
            height: 560px;
        }
        
        .leaflet-interactive {
            /* stroke: #00ff6a; */
            opacity: 0.6;
        }
        
        .leaflet-marker-icon {
            opacity: 1;
        }
        
        .btn {
            text-align: center;
            margin: auto;
            display: block;
            margin-bottom: 20px;
        }
        
        h4 {
            text-align: center;
            margin-bottom: 20px;
        }
        
        #calado_span,
        #calado_sup_span,
        #calado_inf_span {
            margin: auto;
            display: block;
            margin-bottom: 20px;
            padding: 5px;
            text-align: center;
            font-size: 30px;
            border: 2px solid #ffc10a;
            border-radius: 20px;
            width: 150px;
        }
        
        #time {
            margin: auto;
            display: block;
            margin-bottom: 20px;
            padding: 5px;
            text-align: center;
            font-size: 30px;
            border: 2px solid #ffc10a;
            border-radius: 20px;
            width: 150px;
        }
        
        .row,
        .col p {
            text-align: center;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js" type="text/javascript"></script>

    <title>SiSMAR</title>
</head>

<body>
    <h2>Mapa</h2>

    <div class="container">
        <div class="row">
            <div class="col">
                <div id="km"></div>
                <div id="tempoestimado"></div>
                <!-- <p>
                    latitude: <span id="lat"></span><br />
                    longitude: <span id="lng"></span>
                </p> -->
                <input type="file" id="fileUploader" name="fileUploader" accept=".xls, .xlsx" />

            </div>
            <div class="col order-12">
                <div id="clockbox"></div>
            </div>

        </div>
        <h4>Simule uma rota</h4>
        <div class="row">

            <div class="col">
                <p>Calado metro(s)</p>
                <input type="number" id="calado_span" />
            </div>
            <div class="col">
                <p>Limite Superior metro(s)</p>
                <input type="number" id="calado_sup_span" />
            </div>
            <div class="col">
                <p>Limite Inferior metro(s)</p>
                <input type="number" id="calado_inf_span" />
            </div>
            <div class="col">
                <p>TTD</p>
                <input type="time" id="time" />
            </div>

        </div>
    </div>
    <div class="row">
        <div class="col">
            <button type="button" class="btn btn-warning" onclick="changeValue()">Simular</button>
        </div>
        <div class="col">
            <button type="button" class="btn btn-dark" onclick="getDataGPX()">Rota Torreira</button>
        </div>
        <div class="col">
            <button type="button" class="btn btn-dark" onclick="getData2GPX()">Costa Nova</button>
        </div>
        <div class="col">
            <button type="button" class="btn btn-danger" onclick="clearmap()">Apagar</button>
        </div>
    </div>
    </div>
    </div>
    <div id="issMap"></div>

    <script>
        var calado = 1;
        var velocidademedia;
        // Making a map and tiles
        const mymap = L.map('issMap').setView([40.70, -8.69], 11);
        const attribution =
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';

        const tileUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        const tiles = L.tileLayer(tileUrl, {
            attribution
        });
        tiles.addTo(mymap);

        // Making a marker with a custom icon
        const issIcon = L.icon({
            iconUrl: 'marker.png',
            iconSize: [22, 32, 5],
            iconAnchor: [10, 30],
        });
        let marker = L.marker([40.645744, -8.665668], {
            icon: issIcon
        }).addTo(mymap).on('click', onClick);
        mymap.on('zoomend', function() {
            const zoom = mymap.getZoom() + 1;
            // const w = 11 * zoom;
            // const h = 16 * zoom;
            // issIcon.options.iconSize = [44, 65];
            // issIcon.options.iconAnchor = [w / 2, h / 2];
            mymap.removeLayer(marker);
            let latlng = marker.getLatLng();
            marker = L.marker([40.727291289709356, -8.652763366699219], {
                icon: issIcon
            }).addTo(mymap).on('click', onClick);;
            marker.setLatLng(latlng);
        });

        L.control.scale().addTo(mymap);

        //Localização do Utilizador
        mymap.locate({
            setView: true,
            maxZoom: 14
        });

        function onLocationFound(e) {
            var radius = e.accuracy;
            let localiz_distan = [];
            let funcname = [];

            L.marker(e.latlng).addTo(mymap)
                .bindPopup("You are within " + radius + " meters from this point").openPopup();
            console.log(e.latlng.lat);
            console.log(e.latlng.lng);
            L.circle(e.latlng, radius).addTo(mymap);
            let url = 'https://raw.githubusercontent.com/carva28/SiSMAR/master/mytracks_regresso.gpx';
            fetch(url)
                .then(function(response) {
                    return response.text();
                })
                .then(function(json) {
                    VEri_text_gpx = json;
                    parser = new DOMParser();
                    xmlDoc = parser.parseFromString(json, "text/xml");
                    funcname.push('getDataGPX')
                    var lat_gpx = xmlDoc.getElementsByTagName("trkpt")[0].getAttribute('lat');
                    var lon_gpx = xmlDoc.getElementsByTagName("trkpt")[0].getAttribute('lon');

                    distancia = mymap.distance([e.latlng.lat, e.latlng.lng], [lat_gpx, lon_gpx]);

                    localiz_distan.push(distancia);
                });

            let url2 = 'https://raw.githubusercontent.com/carva28/SiSMAR/master/mytracks_2_08.gpx';
            fetch(url2)
                .then(function(response) {
                    return response.text();
                })
                .then(function(json) {
                    VEri_text_gpx = json;
                    parser = new DOMParser();
                    xmlDoc = parser.parseFromString(json, "text/xml");
                    funcname.push('getDataGPX2')
                    var lat_gpx = xmlDoc.getElementsByTagName("trkpt")[0].getAttribute('lat');
                    var lon_gpx = xmlDoc.getElementsByTagName("trkpt")[0].getAttribute('lon');

                    distancia = mymap.distance([e.latlng.lat, e.latlng.lng], [lat_gpx, lon_gpx]);

                    localiz_distan.push(distancia);

                    console.log(localiz_distan.length)
                });
            for (let q = 0; q < localiz_distan.length; q++) {
                console.log(localiz_distan[q])

            }

        }



        mymap.on('locationfound', onLocationFound);



        //var gpx = './mytracks_ida.gpx'; // URL to your GPX file or the GPX itself

        //getDataGPX();

        let text_gpx, arrayGPX = [];
        var VEri_text_gpx;
        async function getDataGPX() {

            mymap.eachLayer(function(layer) {
                //console.log(layer.options.pane)
                if (layer.options.pane == "overlayPane") {
                    mymap.removeLayer(layer);
                }
            });
            let url = 'https://raw.githubusercontent.com/carva28/SiSMAR/master/mytracks_regresso.gpx';
            fetch(url)
                .then(function(response) {
                    return response.text();
                })
                .then(function(json) {
                    VEri_text_gpx = json;

                    var g = new L.GPX(json, {
                        async: true,
                        parseElements: ['track'],
                        polyline_options: {
                            color: '#020202'
                        },
                        marker_options: {
                            'startIcon': new L.icon({
                                iconUrl: 'marker.png',
                                iconSize: [22, 32, 5],
                                iconAnchor: [10, 30],
                            }),
                            'endIcon': new L.icon({
                                iconUrl: 'marker_chegada.png',
                                iconSize: [22, 32, 5],
                                iconAnchor: [10, 30],
                            })
                        }

                    });

                    g.on('loaded', function(e) {
                        var gpx = e.target,
                            elevation_data = gpx.get_elevation_data();
                        data_hora = gpx.get_start_time();
                        name = gpx.get_name(),
                            distM = gpx.get_distance(),
                            distKm = distM / 1000,
                            distKmRnd = distKm.toFixed(1),
                            eleGain = gpx.get_elevation_gain().toFixed(2),
                            eleLoss = gpx.get_elevation_loss().toFixed(2);
                        var info = "Name: " + name + "</br>" +
                            "Distance: " + distKmRnd + " km </br>" +
                            "Elevation Gain: " + eleGain + " m </br>"

                        document.getElementById('km').innerHTML = info;
                        gpx.getLayers()[0].bindPopup(info)

                        let date = new Date(data_hora);
                        let hora_min_gpx = date.getHours() + ":" + date.getMinutes();

                        //document.getElementById('time').value = hora_min_gpx;
                        let nyear = date.getYear();
                        if (nyear < 1000) nyear += 1900;
                        dataViajaUser = [nyear, date.getMonth() + 1, date.getDate()];
                        var arrayhidrografico = [];
                        getInfo2(dataViajaUser[0], dataViajaUser[1], dataViajaUser[2])

                    });
                    g.on('addpoint', function(e) {
                        var gpx = e.target;
                        arrayGPX = [];
                        arrayGPX.push(gpx._gpx)
                    })
                    g.addTo(mymap);
                });

        }

        async function getData2GPX() {
            mymap.eachLayer(function(layer) {
                //console.log(layer.options.pane)
                if (layer.options.pane == "overlayPane") {
                    mymap.removeLayer(layer);
                }
            });
            let url = 'https://raw.githubusercontent.com/carva28/SiSMAR/master/mytracks_2_08.gpx';
            fetch(url)
                .then(function(response) {
                    return response.text();
                })
                .then(function(json) {
                    VEri_text_gpx = json;

                    var g = new L.GPX(json, {
                        async: true,
                        parseElements: ['track'],
                        polyline_options: {
                            color: '#020202'
                        },
                        marker_options: {
                            'startIcon': new L.icon({
                                iconUrl: 'marker.png',
                                iconSize: [22, 32, 5],
                                iconAnchor: [10, 30],
                            }),
                            'endIcon': new L.icon({
                                iconUrl: 'marker_chegada.png',
                                iconSize: [22, 32, 5],
                                iconAnchor: [10, 30],
                            })
                        }

                    });

                    g.on('loaded', function(e) {
                        var gpx = e.target,
                            elevation_data = gpx.get_elevation_data();
                        data_hora = gpx.get_start_time();
                        name = gpx.get_name(),
                            distM = gpx.get_distance(),
                            distKm = distM / 1000,
                            distKmRnd = distKm.toFixed(1),
                            eleGain = gpx.get_elevation_gain().toFixed(2),
                            eleLoss = gpx.get_elevation_loss().toFixed(2);
                        var info = "Name: " + name + "</br>" +
                            "Distance: " + distKmRnd + " km </br>" +
                            "Elevation Gain: " + eleGain + " m </br>"

                        document.getElementById('km').innerHTML = info;
                        gpx.getLayers()[0].bindPopup(info)

                        let date = new Date(data_hora);
                        let hora_min_gpx = date.getHours() + ":" + date.getMinutes();

                        //document.getElementById('time').value = hora_min_gpx;
                        let nyear = date.getYear();
                        if (nyear < 1000) nyear += 1900;
                        dataViajaUser = [nyear, date.getMonth() + 1, date.getDate()];
                        var arrayhidrografico = [];
                        getInfo2(dataViajaUser[0], dataViajaUser[1], dataViajaUser[2])

                    });
                    g.on('addpoint', function(e) {
                        var gpx = e.target;
                        arrayGPX = [];
                        arrayGPX.push(gpx._gpx)
                    })
                    g.addTo(mymap);
                });
        }

        let url3 = 'https://raw.githubusercontent.com/carva28/SiSMAR/master/mytracks_ida_bico.gpx';
        fetch(url3)
            .then(function(response) {
                return response.text();
            })
            .then(function(json) {
                VEri_text_gpx = json;

                var g = new L.GPX(json, {
                    async: true,
                    parseElements: ['track'],
                    polyline_options: {
                        color: '#020202'
                    },
                    marker_options: {
                        'startIcon': new L.icon({
                            iconUrl: 'marker.png',
                            iconSize: [22, 32, 5],
                            iconAnchor: [10, 30],
                        }),
                        'endIcon': new L.icon({
                            iconUrl: 'marker_chegada.png',
                            iconSize: [22, 32, 5],
                            iconAnchor: [10, 30],
                        })
                    }

                });

                g.on('loaded', function(e) {
                    var gpx = e.target,
                        elevation_data = gpx.get_elevation_data();
                    data_hora = gpx.get_start_time();
                    name = gpx.get_name(),
                        distM = gpx.get_distance(),
                        distKm = distM / 1000,
                        distKmRnd = distKm.toFixed(1),
                        eleGain = gpx.get_elevation_gain().toFixed(2),
                        eleLoss = gpx.get_elevation_loss().toFixed(2);
                    var info = "Name: " + name + "</br>" +
                        "Distance: " + distKmRnd + " km </br>" +
                        "Elevation Gain: " + eleGain + " m </br>"

                    document.getElementById('km').innerHTML = info;
                    gpx.getLayers()[0].bindPopup(info)

                    let date = new Date(data_hora);
                    let hora_min_gpx = date.getHours() + ":" + date.getMinutes();


                    var nday = date.getDay(),
                        nmonth = date.getMonth() + 1,
                        ndate = date.getDate(),
                        nyear = date.getYear();
                    if (nyear < 1000) nyear += 1900;
                    UserHoras = new Date(nyear, nmonth, nday, date.getHours(), date.getMinutes());
                    //document.getElementById('time').value = hora_min_gpx;

                    dataViajaUser = [nyear, date.getMonth() + 1, date.getDate()];
                    var arrayhidrografico = [];
                    getInfo2(dataViajaUser[0], dataViajaUser[1], dataViajaUser[2])

                });
                g.on('addpoint', function(e) {
                    var gpx = e.target;
                    arrayGPX = [];
                    arrayGPX.push(gpx._gpx)
                })
                g.addTo(mymap);
            });

        //No clique do marker

        var linesFeatureLayer

        function onClick(e) {
            if (e.latlng.lat == 40.727291289709356 && e.latlng.lng == -8.652763366699219) {
                mymap.eachLayer(function(layer) {
                    //console.log(layer)
                    //console.log(layer.options.pane)
                    if (layer.options.pane == "overlayPane") {
                        mymap.removeLayer(layer);
                    }
                });
                var valorInput = document.getElementById('calado_span').value;
                var valorInput2 = document.getElementById('calado_sup_span').value;
                var valorInput3 = document.getElementById('calado_inf_span').value;
                if (valorInput != "" && valorInput2 != "" && valorInput3 != "") {
                    calculo(valorInput, valorInput2, valorInput3);
                } else {
                    calado = 1;
                    margemcaladoSup = 0.2;
                    margemcaladoInf = 0.1;
                    calculo(1, 0.2, 0.1);
                }

            }
        }
    </script>
    <script>
        var arrayhidrografico = [];
        var array_hidrografico_simulacao_API = [];
        var arrayUser = [];
        $(document).ready(function() {
            $("#fileUploader").change(function(evt) {
                var selectedFile = evt.target.files[0];
                var reader = new FileReader();
                reader.onload = function(event) {
                    var data = event.target.result;
                    var workbook = XLSX.read(data, {
                        type: 'binary'
                    });
                    workbook.SheetNames.forEach(function(sheetName) {

                        var XL_row_object = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName]);
                        var json_object = JSON.stringify(XL_row_object);

                        let jsonparse = JSON.parse(json_object);
                        arrayUser.push(jsonparse);
                        let tempoveri = arrayUser[0][1].T;
                        var newStr = tempoveri.replace(/T/g, " ");
                        let date = new Date(newStr);
                        let horatempoAPI = leadZero(date.getHours()) + ":" + leadZero(date.getMinutes());

                        document.getElementById('time').value = horatempoAPI;
                        let nyear = date.getYear();
                        if (nyear < 1000) nyear += 1900;
                        dataViajaUser = [nyear, date.getMonth() + 1, date.getDate()];
                        var arrayhidrografico = [];
                        getInfo2(dataViajaUser[0], dataViajaUser[1], dataViajaUser[2])

                    })
                };

                reader.onerror = function(event) {
                    console.error("File could not be read! Code " + event.target.error.code);
                };

                reader.readAsBinaryString(selectedFile);
            });
        });
    </script>

    <script type="text/javascript">
        tday = new Array("Domingo", "Segunda-Feira",
            "Terça-Feira", "Quarta-Feira",
            "Quinta-Feira", "Sexta-Feira", "Sábado");
        tmonth = new Array("Janeiro", "Fevereiro", "Março",
            "Abril", "Maio", "Junho", "Julho",
            "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro");

        function GetClock() {
            var d = new Date();
            var nday = d.getDay(),
                nmonth = d.getMonth(),
                ndate = d.getDate(),
                nyear = d.getYear(),
                nhour = d.getHours(),
                nmin = d.getMinutes(),
                nsec = d.getSeconds(),
                ap;

            if (nhour == 0) {
                ap = " AM";
                nhour = 12;
            } else if (nhour < 12) {
                ap = " AM";
            } else if (nhour == 12) {
                ap = " PM";
            } else if (nhour > 12) {
                ap = " PM";
                nhour -= 12;
            }

            if (nyear < 1000) nyear += 1900;
            if (nmin <= 9) nmin = "0" + nmin;
            if (nsec <= 9) nsec = "0" + nsec;

            document.getElementById('clockbox').innerHTML = "" + tday[nday] + ", " + tmonth[nmonth] + " " + ndate + ", " + nyear + " " + nhour + ":" + nmin + ":" + nsec + ap + "";
        }

        window.onload = function() {
            getInfo();
            GetClock();
            setInterval(GetClock, 1000);
        }


        async function getInfo() {
            arrayhidrografico = [];
            array_hidrografico_simulacao_API = [];

            //arrayUser = [];
            sortedData = 0;
            mareUser = [];
            mare_por_minuto = [];
            var d = new Date();
            var nday = d.getDay(),
                nmonth = d.getMonth(),
                ndate = d.getDate(),
                nyear = d.getYear();
            if (nyear < 1000) nyear += 1900;
            console.log(nyear, nmonth + 1, ndate);
            let mescerto = nmonth + 1;
            const proxyurl = "https://cors-anywhere.herokuapp.com/";
            const url = 'https://www.hidrografico.pt/json/mare.graph.val.php?po=13&dd=' + nyear + '-' + mescerto + '-' + ndate + '&nd=0'; // site that doesn’t send Access-Control-*
            fetch(proxyurl + url) // https://cors-anywhere.herokuapp.com/https://example.com
                .then(response => response.json())
                .then(contents => array_hidrografico_simulacao_API.push(contents))
                .then(contents => arrayhidrografico.push(contents))
                .catch(() => console.log("Can’t access " + url + " response. Blocked by browser?"))
        }

        async function getInfo2(ano, mes, dia) {
            arrayhidrografico = [];

            //arrayUser = [];
            sortedData = 0;
            mareUser = [];
            mare_por_minuto = [];
            arrayhidrografico = [];

            const proxyurl = "https://cors-anywhere.herokuapp.com/";
            const url = 'https://www.hidrografico.pt/json/mare.graph.val.php?po=13&dd=' + ano + '-' + mes + '-' + dia + '&nd=0'; // site that doesn’t send Access-Control-*
            fetch(proxyurl + url) // https://cors-anywhere.herokuapp.com/https://example.com
                .then(response => response.json())
                .then(contents => arrayhidrografico.push(contents))
                .catch(() => console.log("Can’t access " + url + " response. Blocked by browser?"))
        }

        function changeValue(e) {
            var valorInput = document.getElementById('calado_span').value;
            var valorInput2 = document.getElementById('calado_sup_span').value;
            var valorInput3 = document.getElementById('calado_inf_span').value;
            if (valorInput != "" && valorInput2 != "" && valorInput3 != "") {
                calculo(valorInput, valorInput2, valorInput3);
            } else {
                calado = 1;
                margemcaladoSup = 0.2;
                margemcaladoInf = 0.1;
                calculo(1, 0.2, 0.1);
            }

        }

        function leadZero(_something) {
            if (parseInt(_something) < 10) return "0" + _something;
            return _something; //else    
        }

        //Realiza o calculo com base no excel
        function calculo(valor_cal, cal_sup, cal_inf) {



            //remover a rota realizada e atualizar
            mymap.eachLayer(function(layer) {
                //console.log(layer.options.pane)
                if (layer.options.pane == "overlayPane") {
                    mymap.removeLayer(layer);
                }
            });
            document.getElementById('calado_span').value = valor_cal;
            document.getElementById('calado_sup_span').value = cal_sup;
            document.getElementById('calado_inf_span').value = cal_inf;

            //atribuir um calado à rota
            var valorInput = document.getElementById('calado_span').value;
            if (valorInput != "") {
                calado = valorInput
            } else {
                calado = 1;
            }
            //selecionar um tempo HH:MM
            var tempo = document.getElementById('time').value;
            let UserHoras2;
            if (tempo != "") {
                var d = new Date();
                var nday = d.getDay(),
                    nmonth = d.getMonth() + 1,
                    ndate = d.getDate(),
                    nyear = d.getYear();
                if (nyear < 1000) nyear += 1900;
                var splitTime1 = tempo.split(':');
                UserHoras2 = new Date(nyear, nmonth, nday, splitTime1[0], splitTime1[1]);

            } else {
                var d = new Date();
                var nday = d.getDay(),
                    nmonth = d.getMonth(),
                    ndate = d.getDate(),
                    nyear = d.getYear();
                if (nyear < 1000) nyear += 1900;
                nhour = d.getHours(), nmin = d.getMinutes();
                // let hora = "20";
                // let min = "00";
                UserHoras2 = new Date(nyear, nmonth, nday, nhour, nmin);
                var now = new Date(Date.now());
                var f = leadZero(now.getHours()) + ":" + leadZero(now.getMinutes());
                document.getElementById('time').value = f;
            }



            var z1_rota_adquirida = [];
            var coordenadas = [];
            let ar_CoordExcel = [],
                horasdarota_medida = [];
            var dataViajaUser = [];

            parser = new DOMParser();
            xmlDoc = parser.parseFromString(arrayGPX[0], "text/xml");
            if (arrayGPX.length != 0 || arrayUser.length != 0) {
                if (arrayUser.length > 0) {
                    for (let m = 0; m < arrayUser.length; m++) {
                        for (let n = 0; n < arrayUser[m].length; n++) {
                            //console.log(arrayUser[m][n])
                            if (arrayUser[m][n].X != "Coordenadas" ||
                                arrayUser[m][n].X != "</trkseg" ||
                                arrayUser[m][n].X != "</trk" ||
                                arrayUser[m][n].X != "</gpx") {

                                if (arrayUser[m][n].T != null || arrayUser[m][n].T != undefined) {
                                    let tempoveri = arrayUser[m][n].T;
                                    var newStr = tempoveri.replace(/T/g, " ");
                                    let date = new Date(newStr);
                                    let horatempo_excel = leadZero(date.getHours()) + ":" + leadZero(date.getMinutes());
                                    if (date.getSeconds() == 00 || date.getSeconds() == 11) {
                                        //Guardar Coordenadas do Excel e Z
                                        ar_CoordExcel.push(arrayUser[m][n])
                                        horasdarota_medida.push(horatempo_excel)
                                    }
                                }
                            }
                        }
                    }
                } else if (arrayGPX[0].length > 0) {
                    for (let i = 0; i < xmlDoc.getElementsByTagName("trkpt").length; i++) {
                        if (xmlDoc.getElementsByTagName("trkpt")[i].children[2].innerHTML != null ||
                            xmlDoc.getElementsByTagName("trkpt")[i].children[2].innerHTML != undefined) {
                            let tempoveri = xmlDoc.getElementsByTagName("trkpt")[i].children[2].innerHTML;
                            var newStr = tempoveri.replace(/T/g, " ");
                            let date = new Date(newStr);
                            let horatempo_GPX = leadZero(date.getHours()) + ":" + leadZero(date.getMinutes());
                            if (date.getSeconds() == 00) {
                                //Guardar Coordenadas do GPX e Z

                                var lat_gpx = xmlDoc.getElementsByTagName("trkpt")[i].getAttribute('lat');
                                var lon_gpx = xmlDoc.getElementsByTagName("trkpt")[i].getAttribute('lon');
                                var z_adquir = xmlDoc.getElementsByTagName("trkpt")[i].children[1].innerHTML;
                                z_adquirido_rota = parseFloat(z_adquir) + 0.4;
                                z1_rota_adquirida.push(z_adquirido_rota)
                                coordenadas.push([lon_gpx, lat_gpx])
                                horasdarota_medida.push(horatempo_GPX)
                            }
                        }
                    }
                }
            }


            let latit, longitu, zadquirido = [];

            if (ar_CoordExcel.length > 0) {

                for (let coord = 0; coord < ar_CoordExcel.length; coord++) {

                    var newlat = ar_CoordExcel[coord].X.replace(/""/g, "");
                    var newlat2 = newlat.replace(/lat=/g, "");
                    var newlat3 = newlat2.replace(/\"/g, "");
                    let newlat4 = parseFloat(newlat3);

                    var newlong5 = ar_CoordExcel[coord].Y.replace(/""/g, "");
                    var newlong6 = newlong5.replace(/lon=/g, "");
                    var newlong7 = newlong6.replace(/\"/g, "");
                    let newlong8 = parseFloat(newlong7);
                    coordenadas.push([newlong8, newlat4])
                    z1_rota_adquirida.push([ar_CoordExcel[coord].Z_offset]);

                }

            } else {
                if (coordenadas.length == 0) {
                    coordenadas = [
                        [-8.762712478637695, 40.64196329226261],
                        [-8.752756118774414, 40.644828856258954],
                        [-8.742284774780273, 40.64593597303585],
                        [-8.73464584350586, 40.65016889724004],
                        [-8.727693557739258, 40.655703854536746],
                        [-8.725204467773438, 40.66117324360654],
                        [-8.72288703918457, 40.66826975856376],
                        [-8.716878890991211, 40.675495708799446],
                        [-8.715934753417969, 40.68363210267408],
                        [-8.717050552368164, 40.692548449646836],
                        [-8.714303970336914, 40.702569780377935],
                        [-8.707437515258789, 40.71102817184792],
                        [-8.696279525756834, 40.71642796756138],
                        [-8.681774139404297, 40.72104672237615],
                        [-8.667354583740234, 40.72481955186487],
                        [-8.652763366699219, 40.727291289709356],
                    ];

                    z1_rota_adquirida = [
                        [3.5],
                        [3.30],
                        [3.4],
                        [3.4],
                        [3.70],
                        [4],
                        [4.5],
                        [3],
                        [3.4],
                        [4],
                        [3.9],
                        [3.20],
                        [3.0],
                        [3.4],
                        [3.5],
                        [3],
                    ];
                }
            }

            var guardarHoras = [];
            let sortedData;
            var mare_por_minuto = [];
            let count = 0,
                mare_max, mare_min, variacaomare, variaca;
            let soma = 0,
                somamare2 = 0;
            var arrayMares = [];
            var mareUser = [];

            if (arrayhidrografico.length > 0) {
                //Ordenar as informação por ordem
                for (let i = 0; i < arrayhidrografico.length; i++) {

                    let UserHorasMin = UserHoras.getHours() + ":" + UserHoras.getMinutes();

                    let datefrente;
                    for (let j = 0; j < arrayhidrografico[i].length; j++) {

                        let date = new Date(arrayhidrografico[i][j].SDATA);
                        let horatempoAPI = date.getHours() + ":" + date.getMinutes();
                        guardarHoras.push(arrayhidrografico[i][j])

                    }
                    sortedData = guardarHoras.sort((a, b) => new Date(a.SDATA) - new Date(b.SDATA))
                }

                //Percorrer o array da informação da maré, com base das horas ordenadas crescente da API Hidrográfico
                for (let k = 0; k < sortedData.length; k++) {

                    let date = new Date(sortedData[k].SDATA);
                    let dataSDATA = date.getHours() + ":" + date.getMinutes();

                    if (sortedData[k + 1] != undefined) {
                        datefrente = new Date(sortedData[k + 1].SDATA);
                    } else {
                        console.log('')
                    }

                    //adicionar a altitude da maré ao arrayMares de forma ordenada com base no tempo
                    arrayMares.push(sortedData[k].ALT)
                    let dataSDATAFrente = datefrente.getHours() + ":" + datefrente.getMinutes();

                    //Verificação com base nas horas do utilizador qual a maré 

                    if (UserHoras.getHours() >= date.getHours() && UserHoras.getHours() < datefrente.getHours()) {
                        console.log(UserHoras.getHours())
                        console.log(date.getHours())
                        console.log(datefrente.getHours())
                        mareUser.push(sortedData[k].ALT)
                    } else {
                        console.log('')
                    }
                }
                let variacaomare, conta;
                // arrayMares => a altitude da maré da API ordenada
                for (let p = 0; p < arrayMares.length; p++) {
                    console.log({
                        mareUser: mareUser[p]
                    });
                    //mareUser é a maré com base na hora do utilizador t1
                    //comparar a altitude da maré que o utilizador fez com a altitude de todas as marés do dia
                    if (arrayMares[p] == mareUser[0]) {

                        // Pretende-se saber qual a altitude da maré da rota do user 
                        // e de seguida guardar esse valor (preia-mar ou baixa-mar)
                        // se não tiver valores para a frente

                        if (arrayMares[p + 1] != null) {

                            variacaomare = arrayMares[p + 1] - arrayMares[p];
                            mare_por_minuto.push(arrayMares[p]);
                            let dc2mare = variacaomare.toFixed(2);

                            for (let a = 1; a < horasdarota_medida.length; a++) {
                                if (mare_por_minuto[a - 1] == null) {} else {
                                    conta = mare_por_minuto[a - 1] + dc2mare / 100;
                                    mare_por_minuto.push(conta);
                                }
                            }
                        } else {
                            variacaomare = arrayMares[p - 1] - arrayMares[p];

                            mare_por_minuto.push(arrayMares[p]);

                            let dc2mare = variacaomare.toFixed(2);

                            for (let a = 1; a < horasdarota_medida.length; a++) {
                                if (mare_por_minuto[a - 1] == null) {} else {
                                    conta = mare_por_minuto[a - 1] + dc2mare / 100;
                                    mare_por_minuto.push(conta);
                                }
                            }
                        }
                    }
                }
            }

            var margemcaladoSup, margemcaladoInf;
            var diferençaTempo, Z2_NOvaRota, z2_menos_calado;
            var linesFeatureLayer, linesFeatureLayer2, linesFeatureLayer3;
            margemcaladoSup = cal_sup;
            margemcaladoInf = cal_inf;
            let sortedData2, mare_por_minuto2 = [];

            //setTimeout(fetchDataRota2, 1000);

            //percorrerRota_Simular();
            var arrayMares2 = [];
            var guardarHoras2 = [];


            if (array_hidrografico_simulacao_API.length > 0) {

                //Ordenar as informação por ordem
                for (let i = 0; i < array_hidrografico_simulacao_API.length; i++) {

                    let datefrente;
                    for (let j = 0; j < array_hidrografico_simulacao_API[i].length; j++) {

                        //Informação da maré do site hidrografico
                        let date = new Date(array_hidrografico_simulacao_API[i][j].SDATA);
                        let horatempoAPI = date.getHours() + ":" + date.getMinutes();
                        guardarHoras2.push(array_hidrografico_simulacao_API[i][j])
                    }
                    sortedData2 = guardarHoras2.sort((a, b) => new Date(a.SDATA) - new Date(b.SDATA))

                }
                console.log(sortedData2)
                let mare_combase_tempo_2 = [];
                //Percorrer o array da informação da maré, com base das horas ordenadas crescente da API Hidrográfico
                for (let k = 0; k < sortedData2.length; k++) {

                    let date = new Date(sortedData2[k].SDATA);
                    let dataSDATA = date.getHours() + ":" + date.getMinutes();

                    if (sortedData2[k + 1] != undefined) {
                        datefrente = new Date(sortedData2[k + 1].SDATA);
                    } else {
                        console.log('')
                    }

                    //adicionar a altitude da maré ao arrayMares de forma ordenada com base no tempo
                    arrayMares2.push(sortedData2[k].ALT)

                    let dataSDATAFrente = datefrente.getHours() + ":" + datefrente.getMinutes();
                    //Verificação com base nas horas do utilizador qual a maré 

                    if (UserHoras2.getHours() >= date.getHours() && UserHoras2.getHours() < datefrente.getHours()) {
                        mare_combase_tempo_2.push(sortedData2[k].ALT)
                    } else {
                        console.log('')
                    }

                }
                let variacaomare2, conta2;
                // arrayMares => a altitude da maré da API ordenada
                for (let p = 0; p < arrayMares2.length; p++) {
                    //mareUser é a maré com base na hora do utilizador t1
                    //comparar a altitude da maré que o utilizador fez com a altitude de todas as marés do dia
                    if (arrayMares2[p] == mare_combase_tempo_2[0]) {
                        console.log({
                                mareuser_atual: mare_combase_tempo_2
                            })
                            // Pretende-se saber qual a altitude da maré da rota do user 
                            // e de seguida guardar esse valor (preia-mar ou baixa-mar)
                            // se não tiver valores para a frente
                        if (arrayMares2[p + 1] != null) {

                            variacaomare2 = arrayMares2[p + 1] - arrayMares2[p];
                            mare_por_minuto2.push(arrayMares[p]);
                            let dc2mare = variacaomare2.toFixed(2);

                            for (let a = 1; a < horasdarota_medida.length; a++) {
                                if (mare_por_minuto2[a - 1] == null) {} else {
                                    conta2 = mare_por_minuto2[a - 1] + dc2mare / 100;
                                    mare_por_minuto2.push(conta2);
                                }
                            }
                        } else {
                            variacaomare2 = arrayMares[p - 1] - arrayMares2[p];

                            mare_por_minuto2.push(arrayMares[p]);

                            let dc2mare = variacaomare2.toFixed(2);

                            for (let a = 1; a < horasdarota_medida.length; a++) {
                                if (mare_por_minuto2[a - 1] == null) {} else {
                                    conta2 = mare_por_minuto2[a - 1] + dc2mare / 100;
                                    mare_por_minuto2.push(conta2);
                                }
                            }
                        }
                    }
                }
            }

            // let z2_cal_rota_nova = [];
            // for(let k = 0; k<horasdarota_medida.length;k++){
            //     console.log({array_mares:mare_por_minuto[k],
            //     horas:horasdarota_medida[k],
            //     z_rota:parseFloat(z1_rota_adquirida[k])})
            //     let z2_calcular = mare_por_minuto2[k] - mare_por_minuto[k];
            //     let z2_total = mare_por_minuto[k]+z2_calcular;
            //     z2_cal_rota_nova.push(z2_total)
            // }


            let distancia;
            let arDistan = [];
            let countdangerous = 0;
            let warning = 0;
            let diferençaAlturaMare = 0;
            if (mare_por_minuto.length > 0) {

                for (var i = 0; i < coordenadas.length; i++) {
                    //diferençaAlturaMare = nivel_mare[i][0] - nivel_mareNOVA[i][0];

                    //diferençaAlturaMare = z2_cal_rota_nova[i][0] - mare_por_minuto[i];

                    if (mare_por_minuto2.length > 0) {
                        diferençaAlturaMare = parseFloat(mare_por_minuto2[i]) - parseFloat(mare_por_minuto[i]);
                        //diferençaAlturaMare = mare_por_minuto[i];
                    }

                    if (z1_rota_adquirida[i][0] > 0) {
                        Z2_NOvaRota = z1_rota_adquirida[i][0] + diferençaAlturaMare;

                    } else {
                        Z2_NOvaRota = z1_rota_adquirida[i] + diferençaAlturaMare;
                    }
                    z2_menos_calado = Z2_NOvaRota - parseFloat(calado);
                    // console.log({
                    //     mare1_min: mare_por_minuto[i],
                    //     mare2_min: mare_por_minuto2[i],
                    //     calado: calado,
                    //     alturaMare: diferençaAlturaMare,
                    //     z1: z1_rota_adquirida[i][0],
                    //     z1gpx:z1_rota_adquirida[i]
                    //     z2: Z2_NOvaRota,
                    //     z2_menos_calado: z2_menos_calado
                    // })

                    //console.log(verificarRota)
                    if (z2_menos_calado < margemcaladoInf) {
                        if (coordenadas[i + 1] != undefined) {
                            //console.log('vermelho' + verificarRota)
                            var myLines1 = [{
                                "type": "LineString",
                                'coordinates': [
                                    [coordenadas[i][0], coordenadas[i][1]],
                                    [coordenadas[i + 1][0], coordenadas[i + 1][1]],
                                ]
                            }];
                            distancia = mymap.distance([coordenadas[i][0], coordenadas[i][1]], [coordenadas[i + 1][0], coordenadas[i + 1][1]]);
                            arDistan.push(distancia.toFixed(2));
                            var myStyle1 = {
                                radius: 8,
                                color: "red",
                                weight: 5,
                                opacity: 1,
                            };

                            linesFeatureLayer = L.geoJson(myLines1, {
                                style: myStyle1
                            });
                            linesFeatureLayer.addTo(mymap);
                            countdangerous++;
                        } else {
                            //console.log('')
                        }
                    } else if (z2_menos_calado >= margemcaladoInf && z2_menos_calado <= margemcaladoSup) {

                        if (coordenadas[i + 1] != undefined) {
                            //console.log('amarelo' + verificarRota)
                            var myLines2 = [{
                                "type": "LineString",
                                'coordinates': [
                                    [coordenadas[i][0], coordenadas[i][1]],
                                    [coordenadas[i + 1][0], coordenadas[i + 1][1]],
                                ]
                            }];
                            distancia = mymap.distance([coordenadas[i][0], coordenadas[i][1]], [coordenadas[i + 1][0], coordenadas[i + 1][1]]);
                            arDistan.push(distancia.toFixed(2));
                            var myStyle2 = {
                                radius: 8,
                                color: "yellow",
                                weight: 5,
                                opacity: 1,
                            };

                            linesFeatureLayer2 = L.geoJson(myLines2, {
                                style: myStyle2
                            });
                            linesFeatureLayer2.addTo(mymap);
                            warning++;

                        } else {
                            console.log('')
                        }
                    } else if (z2_menos_calado >= margemcaladoSup) {

                        if (coordenadas[i + 1] != undefined) {
                            //console.log('verde' + verificarRota)
                            var myLines3 = [{
                                "type": "LineString",
                                'coordinates': [
                                    [coordenadas[i][0], coordenadas[i][1]],
                                    [coordenadas[i + 1][0], coordenadas[i + 1][1]],
                                ]
                            }];
                            distancia = mymap.distance([coordenadas[i][0], coordenadas[i][1]], [coordenadas[i + 1][0], coordenadas[i + 1][1]]);
                            arDistan.push(distancia.toFixed(2));

                            var myStyle3 = {
                                radius: 8,
                                color: "green",
                                weight: 5,
                                opacity: 1,
                            };

                            linesFeatureLayer3 = L.geoJson(myLines3, {
                                style: myStyle3
                            });
                            linesFeatureLayer3.addTo(mymap);
                            if (countdangerous < warning) {
                                popup = L.popup()
                                    .setLatLng([coordenadas[i][1], coordenadas[i][0]])
                                    .setContent('<p>Pode encanlhar em alguns pontos</p>')
                                    .openOn(mymap);
                            } else if (warning > 0) {
                                popup = L.popup()
                                    .setLatLng([coordenadas[i][1], coordenadas[i][0]])
                                    .setContent('<p>Possibilidade de encanlhar</p>')
                                    .openOn(mymap);
                            } else if (countdangerous > 0) {
                                popup = L.popup()
                                    .setLatLng([coordenadas[i][1], coordenadas[i][0]])
                                    .setContent('<p>Pode encanlhar em alguns pontos</p>')
                                    .openOn(mymap);
                            } else {
                                popup = L.popup()
                                    .setLatLng([coordenadas[i][1], coordenadas[i][0]])
                                    .setContent('<p>Pode viajar com segurança</p>')
                                    .openOn(mymap);
                            }
                        }
                    }

                }
            } else {
                calculo(valor_cal, cal_sup, cal_inf)
            }


            let sum = 0;
            for (let u = 0; u < arDistan.length; u++) {
                sum += parseFloat(arDistan[u]);
            }
            let totavelkm2kn, tempovm;
            let minutesfinal, minutes2deci, dc2tempovm;
            let newsum = sum / 1000;
            document.getElementById('km').innerHTML = "<p>" + newsum.toFixed(2) + " KM </p>";
            velocidademedia = 5;
            totavelkm2kn = newsum / 1.852;
            tempovm = totavelkm2kn / velocidademedia;
            dc2tempovm = tempovm.toFixed(2);
            dc2tempovm = dc2tempovm.split('.');
            let knowminutes = 0 + '.' + dc2tempovm[1];

            minutesfinal = parseFloat(knowminutes) * 60;
            let min = minutesfinal.toFixed(1);
            let spantempo = dc2tempovm[0] + 'h' + parseInt(min) + 'm';
            document.getElementById('tempoestimado').innerHTML = "<p>" + spantempo + "</p>";
        }




        function clearmap() {
            mymap.eachLayer(function(layer) {
                //console.log(layer.options.pane)
                if (layer.options.pane == "overlayPane") {
                    mymap.removeLayer(layer);
                }
            });

            document.getElementById('calado_span').value = "";
            document.getElementById('calado_sup_span').value = "";
            document.getElementById('calado_inf_span').value = "";
            document.getElementById('time').value = 0;
            arrayhidrografico = [];
            arrayUser = [];
            sortedData = 0;
            mareUser = [];
            mare_por_minuto = [];
            document.getElementById('fileUploader').value = "";
            getInfo();
        }
    </script>

</body>

</html>